<html>
<head>
<title>Web Inspector Web App Over crx2app</title>

<script src="lib/crx2app/extension/appEnd/proxyChromePipe.js"></script>
<script src="lib/crx2app/extension/lib/q/q.js"></script>
<script src="lib/crx2app/extension/lib/requirejs/require.js"></script>
<script>

/*globals chromeExtensionPipe window console Q require */

var debug = false;

// Base URL for crx2app

var iframeDomain ="chrome-extension://bbjpappmojnmallpnfgfkjmjnhhplgog";

var connection = chromeExtensionPipe.createFrom(iframeDomain);

window.beforeUnloadQueue = [];
window.onbeforeunload = function runQueue() {
  window.beforeUnloadQueue.forEach(function(fnc) {
    fnc();
  });
};

// dynamic iframe load
//
function appendFrame(id, url, onload) {
  var iframe = document.createElement('iframe');
  iframe.setAttribute('src', url);
  var elt = document.getElementById(id);
  elt.appendChild(iframe);
  return iframe;
}

function showInspectorIframe() {
    var inspectorElt = document.getElementById('WebInspector');
    inspectorElt.classList.remove('hide');
    return appendFrame('WebInspector', "inspector/front-end/devtools.html");
}


// Promise the inspectorWindow only after the load event is processed

function openInspector(debuggee, chromeProxy) {
  var deferred = Q.defer();
  var inspectorElt = showInspectorIframe();
  var inspectorWindow = inspectorElt.contentWindow;
  
  // Capture the DOMContentLoaded to monkey patch inspectorWindow.
  //
  inspectorWindow.addEventListener('DOMContentLoaded', function(event){
    
    if (debug) {
      console.log("DOMContentLoaded on inspectorWindow ", debuggee);
    }

    function sendMessageObject(messageObject) {
      if (debug) {
        console.log(messageObject.id+" atopwi sendCommand "+messageObject.method);
      }
      chromeProxy.debugger.sendCommand(debuggee, messageObject.method, messageObject.params, function(data) {
         data.id = messageObject.id;
         if (debug) {
           console.log(data.id+" atopwi response to sendCommand "+messageObject.method, {messageObject: messageObject, data: data});
         }
         inspectorWindow.InspectorBackend.dispatch(data); 
      });
    }
    
    inspectorWindow.InspectorBackend.sendMessageObjectToBackend = sendMessageObject;
    
    chromeProxy.jsonHandlers['chrome.debugger.remote'] = {
      jsonObjectHandler:  function(data) {
        if (debug) {
          console.log("jsonObjectHandler "+data.method, data);
        }
        inspectorWindow.InspectorBackend.dispatch.apply(inspectorWindow.InspectorBackend, [data]);
      }
    };
    
    inspectorWindow.InspectorFrontendHost.sendMessageToBackend = function() {
      throw new Error("Should not be called");
    };
    
    // This method is called asynchronously from WebInspector _initializeCapability
    var stock_doLoadedDoneWithCapabilities = inspectorWindow.WebInspector._doLoadedDoneWithCapabilities;
    
    inspectorWindow.WebInspector._doLoadedDoneWithCapabilities = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      stock_doLoadedDoneWithCapabilities.apply(this, args);
      
      deferred.resolve(inspectorWindow);
    };
    
  }, true);
  return deferred.promise;
}

function promiseNewTabId(url, chromeProxy) {
  var deferred = Q.defer();
  var win = chromeProxy.promiseNewWindow();
  Q.when(win, function(win) {
    var tabId = win.tabs[0].id;
    if (debug) {
      console.log("atopwi promiseNewTabId "+tabId);
    }
    deferred.resolve(tabId);
  });
  return deferred.promise;
}

function promiseDebuggee(debuggee, chromeProxy) {
  var deferred = Q.defer();
  if ( debuggee.url ) {  
    var newTabId = promiseNewTabId(debuggee.url, chromeProxy);
     Q.when(newTabId, function(newTabId) {
       debuggee.tabId = newTabId;
       window.beforeUnloadQueue.push(function() {
         chromeProxy.tabs.remove(newTabId);
         debugger;  // stopping in the debugger is the only way I can get the window to close
       });
       deferred.resolve(debuggee);
     }, console.error).end();
  } else {
    deferred.resolve(debuggee);
  }
  return deferred.promise;
}

function parseDebuggee(debuggeeSpec) {
  var debuggee = {};
  var tabId = parseInt(debuggeeSpec.tabId, 10);
  if ( isNaN(tabId) ) {  // then we better have a URL
    debuggee.url = debuggeeSpec.url;
  } else {
    debuggee.tabId = tabId;
  }
  return debuggee;
}

function openDebuggee(debuggeeSpec) {
  // dynamically load the chrome proxy
    require({
      paths: {
        "crx2app": "lib/crx2app/extension"
      }
    }); 
   require.onError = function(err) {
     console.error(err+"", {stack: err.stack.split('\n')});
   };

   require(['crx2app/rpc/ChromeProxy'], function open(ChromeProxy) {
     var chromeProxy = ChromeProxy.new(connection, {windows: {}, tabs: {}});
     var debuggee = parseDebuggee(debuggeeSpec);
     debuggee = promiseDebuggee(debuggee, chromeProxy);
     Q.when(debuggee, function(debuggee) {
       chromeProxy.debugger.attach({tabId: debuggee.tabId}, "1.0", function() {
         if (debug) {
           console.log("atopwi chrome.debugger.attach complete "+debuggee.tabId);
         }
         
         window.beforeUnloadQueue.unshift(function() {
           chromeProxy.debugger.detach({tabId: debuggee.tabId});
         });
         
         var inspectorReady = openInspector(debuggee, chromeProxy);
         Q.when(inspectorReady, function(inspectorReady) {
           if (debuggee.url) {
             if (debug) {
               console.log("atopwi setting URL:"+debuggee.url);
             }
             chromeProxy.tabs.update(debuggee.tabId, {url: debuggee.url}, function(tab) {
               if (debug) {
                 console.log("atopwi.chrome.tabs.update "+debuggee.tabId+" to "+debuggee.url);
               }
             });
           }
         });
       });
       
     }).end();
   });
} 

function attach(debuggeeSpec) {

  var tid = setTimeout(function offerExtension() {
    window.alert("Someday this will point you to an extension download");
  }, 2000);
  
  // listen for a connection.
  connection.attach(function onConnectedToChrome() {
  
    // we have connected to the extension, so clear the offer
    clearTimeout(tid);
    
    openDebuggee(debuggeeSpec);
    
  }, function errback(msg) {
    var div = document.querySelector("#error");
    div.innerHTML = msg;
  });
  
  // dynamically load the chromeIframe, it will connect and fire the callback
  // (if we load the iframe statically, 
  // this outer load event will come *after* the iframe load event.)
  appendFrame('loadChromeIframe', iframeDomain + "/appEnd/chromeIframe.html");
}

function extractDebuggeeFromURL() {
  var search = window.location.search;
  if (search) {
    var parameterString = search.substr(1);
    if (parameterString) {
      var params = {};
      parameterString.split('&').forEach(function(param) {
        var nv = param.split('=');
        if (nv.length === 2 && nv[1]) {
          params[nv[0]] = nv[1];
        }
      });
      if (Object.keys(params).length) {
        return params;
      }
    }
  } // else undefined
}

function reloadWithURL(debuggeeURLElt) {
  var debuggeeURL = debuggeeURLElt.value;
  var base = window.location.href;
  base = base.split('?')[0];
  var relo = "debuggee="+encodeURIComponent(debuggeeURL)+'&';
  window.open(base+'?'+relo);
}


function promptForDebuggee() {
  var deferred = Q.defer();
  var debuggeeURLElt = document.getElementById('debuggeeURLElt');
  
  var debuggee = document.getElementById('debuggeeSpec');
  debuggee.classList.remove('hide');
  
  var doDebug = document.getElementById('doDebug');
  doDebug.addEventListener('click', function(event) {
    debuggee.classList.add('hide');
    deferred.resolve(debuggeeURLElt.value);
  }, false);

  debuggee.addEventListener('keypress', function(event) {
    if (event.keyCode === 13) {
      debuggee.classList.add('hide');
      deferred.resolve(debuggeeURLElt.value);
    }
  }, true);
  return deferred.promise;
}

function getDebuggeeSpec() {
  var debuggeeSpec = extractDebuggeeFromURL();
  if (debuggeeSpec) {
    return debuggeeSpec;
  } else {
    var defaultDebuggeeURL = "http://johnjbarton.github.com/webdev-examples/simple/scriptTagJSProject/index.html";
    if (window.confirm("Use "+defaultDebuggeeURL)) {
      return {url: defaultDebuggeeURL};
    }
  }
}

function onLoad() {
  // clean up
  window.removeEventListener('load', onLoad, false);

  var debuggeeSpec = getDebuggeeSpec();
  
  // connect to the chromeIframe
  Q.when(debuggeeSpec, function(debuggeeSpec) {
    attach(debuggeeSpec);
  }, function(err) {
    console.error(err);
  }).end();
}

window.addEventListener('load', onLoad, false);

window.beforeUnloadQueue.push(function detach() {
  connection.detach();
});

</script>
<style>
html, body, iframe {
  height: 100%;
  width: 100%;
  margin: 0px;  /* kill off any margin so we control */
  border: none;
}
body {
  font-family:Verdana,Geneva,sans-serif;
}
.hide {
  display: none;
}
#debuggee {
  margin: 20px;
}
</style>
</head>
<body>
<div class='hide' id='error'></div>
<div class='hide' id='debuggeeSpec'>
<h1> Chrome Devtools as Web App using crx2app extension </h1>
<form >
URL: <input id='debuggeeSpecURLElt' type='url' size='128'/><button id="doDebug">Debug</button>
</form>
</div>
<div class='hide' id="WebInspector"></div>
<div class= 'hide' id="loadChromeIframe"></div>
</body>
</html>